// common functions to generate reports

use crate::utils::{
   csv_utils::CsvWriter,
   html_utils::{a,ol,p,h,Mode,roff,proff}
};

pub fn print_footer(mode: &Mode, src_dir: &str, program: &str) {
   let repo = "https://github.com/logicalgraphs/crypto-n-rust/blob/main";
   let source = format!("{src_dir}/{program}.rs");
   let url = format!("{repo}/{source}");
   let prelude = "Report generated by";
   let prog = format!("./{program}");
   let sub_url = roff(mode, &a(&url, &prog));
   proff(&p(&format!("{prelude} {sub_url}")), &mode);
}

pub fn print_message(mode: &Mode, mesg: &str) {
   proff(&p(mesg), mode);
}

pub fn print_top<T: CsvWriter + Clone>(n: usize, title: &str, date: &str, 
      lps: &Vec<T>, mode: &Mode) {
   let mut new_lps: Vec<T> = Vec::new();
   let mut x = 1;
   for b in lps {
      if x > n { break; }
      new_lps.push(b.clone());
      x += 1;
   }
   print_top_of(title, date, &new_lps, mode);
}

pub fn print_top_by<T: CsvWriter + Clone>(f: impl FnMut(&T) -> bool, 
      title: &str, date: &str, lps: &Vec<T>, mode: &Mode) {
   let mut new_lps: Vec<T> = lps.to_vec();
   new_lps.retain(f);
   print_top_of(title, date, &new_lps, mode);
}

pub fn print_top_of<T: CsvWriter>(title: &str, date: &str, lps: &Vec<T>, 
      mode: &Mode) {
   let n = lps.len();
   let header = format!("Top {n} {title}, {date}");
   proff(&h(2, &header), mode);
   let stringy: Vec<String> = lps.iter().map(|a| a.as_csv()).take(n).collect();
   proff(&ol(&stringy), mode);
}
