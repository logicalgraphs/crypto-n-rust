// common functions to generate reports

use strum_macros::EnumIter; // 0.17.1

use crate::{
   csv_utils::CsvWriter,
   html_utils::{a,ol,p},
   string_utils::to_string
};

#[derive(PartialEq, EnumIter)]
pub enum Mode { HTML, TEXT }

pub fn mk_mode(m: &str) -> Mode {
   match m.to_lowercase().as_str() {
      "html" => Mode::HTML,
      "text" => Mode::TEXT,
      _      => panic!("Do not know the mode {}", m)
   }
}

pub fn print_footer(mode: &Mode, src_dir: &str, program: &str) {
   let repo = "https://github.com/logicalgraphs/crypto-n-rust/blob/main";
   let source = format!("{src_dir}/{program}.rs");
   let url = format!("{repo}/{source}");
   let prelude = "Report generated by";
   let prog = format!("./{program}");
   let blurb = if mode == &Mode::HTML {
      let sub_url = a(&url, &prog);
      p(&format!("{prelude} {sub_url}"))
   } else {
      format!("{prelude} {prog}:\n{url}")
   };
   println!("{blurb}");
}

pub fn print_message(mode: &Mode, mesg: &str) {
   let paragraph = if mode == &Mode::TEXT { to_string } else { p };
   println!("{}\n", paragraph(mesg))
}

pub fn print_top<T: CsvWriter + Clone>(n: usize, title: &str, date: &str, 
      lps: &Vec<T>, mode: &Mode) {
   let mut new_lps: Vec<T> = Vec::new();
   let mut x = 1;
   for b in lps {
      if x > n { break; }
      new_lps.push(b.clone());
      x += 1;
   }
   print_top_of(title, date, &new_lps, mode);
}

pub fn print_top_by<T: CsvWriter + Clone>(f: impl FnMut(&T) -> bool, 
      title: &str, date: &str, lps: &Vec<T>, mode: &Mode) {
   let mut new_lps: Vec<T> = lps.to_vec();
   new_lps.retain(f);
   print_top_of(title, date, &new_lps, mode);
}

pub fn print_top_of<T: CsvWriter>(title: &str, date: &str, lps: &Vec<T>, 
      mode: &Mode) {
   let n = lps.len();
   let headerf = if mode == &Mode::HTML { p } else { to_string };
   let listerf = if mode == &Mode::HTML { ol } else { list };
   let header = format!("Top {n} {title}, {date}");
   println!("{}\n", headerf(&header));
   let stringy: Vec<String> = lps.iter().map(|a| a.as_csv()).take(n).collect();
   println!("{}\n", listerf(&stringy));
}

fn list(l: &Vec<String>) -> String {
   let mut i = 1;
   let mut ans = String::new();
   for x in l {
      ans = format!("{ans}\n{i},{x}");
      i += 1;
   }
   ans
}
